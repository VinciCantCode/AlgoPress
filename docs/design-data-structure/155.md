# 155. Min Stack
<Badge type="warning" text="Medium" />[<Badge type="info" text="LeetCode" />](https://leetcode.com/problems/min-stack/)

Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the `MinStack` class:
- `MinStack()` initializes the stack object.
- `void push(int val)` pushes the element val onto the stack.
- `void pop()` removes the element on the top of the stack.
- `int top()` gets the top element of the stack.
- `int getMin()` retrieves the minimum element in the stack.

You must implement a solution with O(1) time complexity for each function.

Example
> Input: ["MinStack","push","push","push","getMin","pop","top","getMin"]
> [[],[-2],[0],[-3],[],[],[],[]]
>
> Output: [null,null,null,null,-3,null,0,-2]
>
> Explanation:
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.getMin(); // return -3
> minStack.pop();
> minStack.top();    // return 0
> minStack.getMin(); // return -2

Constraints
- `-2^{31} <= val <= 2^{31} - 1`
- Methods pop, top and getMin operations will always be called on non-empty stacks.
- At most 3 * 10^4 calls will be made to push, pop, top, and getMin.

## How to solve the problem

- Stack with Min Stack, O(1)

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []  # stores the minimum at each level

    def push(self, val: int) -> None:
        self.stack.append(val)
        # If min_stack is empty or val is the new minimum, push it to min_stack
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        val = self.stack.pop()
        # Only pop from min_stack if the popped value is the current minimum
        if val == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        # The top of min_stack is always the current minimum
        return self.min_stack[-1]
```
- Build in, getMin O(n)

```python
class(MinStack):
    def __init__(self):
        self.stack = []

    def push(self, val) -> None:
        self.stack.append(val)

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return min(self.stack)
```

## Complexity
- Time complexity: O(1) per operation, Space complexity: O(n)
- Time complexity: o(1) per operation except getMin O(n), Space complexity: O(n)

